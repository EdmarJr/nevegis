<html>
<head>
	<link href="icpbravo.css" rel="stylesheet" type="text/css" />
	<title>ICPBravo - Manual do Desenvolvedor .NET</title>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
	
	<script type="text/javascript" src="../scripts/shCore.js"></script>
	<script type="text/javascript" src="../scripts/shBrushCSharp.js"></script>
	<script type="text/javascript" src="../scripts/shBrushCss.js"></script>
	<script type="text/javascript" src="../scripts/shBrushDiff.js"></script>
	<script type="text/javascript" src="../scripts/shBrushJava.js"></script>
	<script type="text/javascript" src="../scripts/shBrushJScript.js"></script>
	<script type="text/javascript" src="../scripts/shBrushPlain.js"></script>
	<script type="text/javascript" src="../scripts/shBrushXml.js"></script>
	<link type="text/css" rel="stylesheet" href="../styles/shCore.css"/>
	<link type="text/css" rel="stylesheet" href="../styles/shThemeMidnight.css"/>
	<script type="text/javascript">
		SyntaxHighlighter.config.clipboardSwf = '../scripts/clipboard.swf';
		SyntaxHighlighter.all();
	</script>
</head>
<body>
	<table width='100%'><tr>
	<td align='left'><a href='index.html'><img src='../img/LogoGrande.png' border='0'></a></td>
	<td align='right'><h1><a href='http://www.oaks.com.br'>OAK Soluções Empresariais</a></h1></td>
	</tr>
	</table>
<h1>ICPBravo - Manual do Desenvolvedor .NET</h1>
<p>O presente manual ajudará o desenvolvedor a construir aplicações com o uso da API ICPBravo em ambiente .NET.</p>
Os seguintes capítulos poderão ser verificados neste manual.
<ul>
<!-- 
<li><h2><a href='desenvolvedor.html#chavesSimetricas()'>Algoritmos Simétricos</a></h2></li>
<li><h2><a href='desenvolvedor.html#chavesAssimetricas()'>AlgoAlgoritmos Assimétricos ou Algoritmos de Chave Pública</a></h2></li>
<li><h2><a href='desenvolvedor.html#digest()'>Algoritmos de Digest</a></h2></li>
<li><h2><a href='desenvolvedor.html#numerosAleatorios()'>Números Aleatórios</a></h2></li>
<li><h2><a href='desenvolvedor.html#pkcs()'>PKCS - Public Key Criptography Standards</a></h2></li>
<li><h2><a href='desenvolvedor.html#asn1()'>ASN.1 - Abstract Syntax Notation number one</a></h2></li>
 -->
<li><h2><a href='desenvolvedor.html#certificadosDigitais()'>Certificados Digitais</a></h2></li>
<li><h2><a href='desenvolvedor.html#signedData()'>Assinaturas Digitais</a></h2></li>
<!-- 
<li><h2><a href='desenvolvedor.html#envelopedData()'>Pacotes de Criptografia</a></h2></li>
<li><h2><a href='desenvolvedor.html#csr()'>CSR - Certificate Signing Request</a></h2></li>
-->
</ul>

<hr>
<!-- 
<A NAME="chavesSimetricas()"><!-- - -></A>
<h2>Algoritmos Simétricos</h2>
<p>Algoritmos simétricos são algoritmos onde a chave para criptografar e decriptografar o conteúdo é a mesma.</p>
<p>Estes algoritmos tem como benefício a característica de serem rápidos, porém sua maior fragilidade consiste no fato da divulgação do segredo para as duas partes, que pode sofrer algum tipo de interceptação, colocando toda a seguraça da criptografia por água abaixo.</p>
<pre class="brush: java;">
// Criar uma chave simétrica
KeyGenerator generator = KeyGenerator.getInstance("DES", "ICPBRAVO");
generator.init(112);
SecretKey key = generator.generateKey();

// Instanciar um novo objeto do tipo Cipher
Cipher cipher = Cipher.getInstance("DES/CBC/PKCS5PADDING","ICPBRAVO");

// Contruir os parâmetros adequados para o tipo de bloco desejado
AlgorithmParameterSpec parm = new IvParameterSpec(new byte[8]); 

// Inicializar o algoritmo no modo desejado
cipher.init(Cipher.ENCRYPT_MODE, key, parm);

// Criptografar o conteúdo de plainText em cryptDoc 
byte [] plainText = "text original".getBytes();
byte [] cryptDoc = cipher.doFinal(plainText)

// Retornar o conteúdo com a chave secreta
cipher.update(Cipher.DECRYPT_MODE, key, parm);
byte [] decryptDoc = cipher.doFinal(cryptDoc)

</pre>
<p>Alguns problemas foram observados no uso desta forma, que são:</p>
<ul>
<li>Em primeiro lugar, todos os parâmetros são sempre passados as Factory's por meio de strings. Isto pode ocasionar falhas frequentes de erros de digitação, que não poderão ser verificadas em tempo de compilação e que só poderão ser observadas na execução do código.</li>
<li>Necessidade de conhecimento aprofundado de cada parâmetro exigido pelo algoritmo desejado, como pode ser observado nas linhas de inicialização da chaveSecreta e na inicialização do objeto cipher, que no caso de falhas, também só poderão ser observadas em tempo de execução.</li>
<li>Seleção do algoritmo por meio de string, que força que a JRE seja configurada de antemão para suportar o provider, fazendo com que o procedimento de instalação dos aplicativos se torne mais complexo.</li>
</ul>
<p>A API ICPBravo proporciona uma alternativa para se utilizar destes algoritmos, de forma a minimizar estes problemas mencionados, fazendo com que as eventuais falhas de utilização dos algoritmos já possam ser observadas em tempo de compilação, conforme o trecho de código abaixo:</p>
<pre class="brush: java;">
// Instanciar o objeto que representa o algoritmo
SymmetricAlgorithm alg = new AES256CBC();

// Criar uma chave simétrica
SecretKey key = alg.generateKey();

// Criptografar o conteúdo de plainText em cryptDoc 
byte [] plainText = "text original".getBytes();
byte [] cryptDoc = alg.crypt(plainText, key);

// Retornar o conteúdo com a chave secreta
byte [] decryptDoc = alg.decrypt(cryptDoc, key);
</pre>
<p>Perceba que, fora as visíveis diminuições nas quantidades de linhas do programa para se efetuar a mesma lógica, não foi mais necessário decorar as strings de parâmetro do algoritmo utilizado.</p>
<p>Veja que, caso digitássemos o nome do algoritmo de forma errada, como por exemplo AES256CBC, o compilador daria um erro informando que o algoritmo em questão não existe, visto que não é uma classe implementada, sendo que no modo anterior, se inicializássemos a chave com 256 bits ao invés de 112, o erro só poderia ser observado em tempo de execução, uma vez que o algoritmo em questão não suporta este tamanho de chave.</p>
<p>Este mesmo padrão poderá ser observado para as demais classes de algoritmos, como os assimétricos, digest, chaves aleatórias, etc., portanto a partir de agora, demonstraremos o uso dos algoritmos apenas com o uso das classes da API.</p>
<p>Veja mais exemplos do uso de algoritmos simétricos em <a href='javadoc/br/com/oaks/ICPBravo/Exemplos.html#testaCifrasSimetricas()'>Exemplos</a></p>
<A NAME="chavesAssimetricas()"><!-- - -></A>
<h2>Algoritmos Assimétricos ou Algoritmos de Chave Pública</h2>
<p>Algoritmos assimétricos são algoritmos onde utilizam-se de pares de chaves. Uma chave é utilizada na criptografia da mensagem e a outra chave é utilizada na descriptografia.</p>
<p><b>Algoritmos Suportados</b></p>
<ul>
<li>DSA</li>
<li>RSA</li>
<li>ECDSA (RFC 5480)</li>
</ul>
<p><b>Geração de chaves</b></p>
<p>São Geradas chaves para DSA 512,RSA 1024, RSA 2048, RSA 4096, ECDSA 256, ECDSA 512.</p>
<p>A API ICPBravo também implementa classes que permitem o uso das capacidades destes algoritmos, como pode ser verificado no trecho de código abaixo.</p>
<pre class="brush: java;">
// Instanciar o objeto que representa o algoritmo
AsymmetricAlgorithm alg = new RSA1024ECB(new ICPBravoProvider());

// Criar um par de chaves assimétricas
KeyPair key = alg.generateKeyPair();

// Criptografar o conteúdo de plainText em cryptDoc com a chave privada
byte [] plainText = "text original".getBytes();
byte [] cryptDoc = alg.crypt(plainText, key.getPrivate());

// Retornar o conteúdo com a chave pública
byte [] decryptDoc = alg.decrypt(cryptDoc, key.getPublic());
</pre>
<p>Veja que, ao contrário do algoritmo simétrico, foram utilizadas duas chaves. Uma para criptografar e outra para descriptografar.</p>
<p>Veja mais exemplos do uso de algoritmos assimétricos em <a href='javadoc/br/com/oaks/ICPBravo/Exemplos.html#testaCifrasAssimetricas()'>Exemplos</a></p>
<A NAME="digest()"><!-- - -></A>
<h2>Algoritmos de Digest</h2>
<p>Nas operações de assinaturas, é comum criarmos um resumo do documento assinado para que, ao aplicá-lo em algoritmos assimétricos, não consumam um tempo excessivamente longo.</p>
<p>Um algoritmo de digest, ou também conhecido como algoritmo de hash é uma seqüencia de bits geradas por um algoritmo de dispersão, em geral representada em base hexadecimal, que permite a visualização em letras (A a F) e números, representando 2 bytes cada.
O conceito teórico diz que <i>"hash é a transformação de uma grande quantidade de informações em uma pequena quantidade de informações"</i>.</p>
<p>Essa seqüencia busca identificar um arquivo ou informação unicamente, como por exemplo, uma mensagem de correio eletrônico, uma senha, uma chave criptográfica ou mesmo um arquivo.</p>
<p>É um método para transformar dados de tal forma que o resultado seja (quase) exclusivo. Além disso, funções usadas em criptografia garantem que não é possível a partir de um valor de hash retornar à informação original. Como a seqüencia do hash é limitada, muitas vezes não passando de 512 bits, existem colisões (seqüências iguais para dados diferentes). Quanto maior for a dificuldade de se criar colisões intencionais, melhor é o algoritmo.</p>
<p>Uma função de hash recebe um valor de um determinado tipo e retorna um código para ele. Enquanto o ideal seria gerar identificadores únicos para os valores de entrada, isso normalmente não é possível: na maioria dos casos, o contra-domínio de nossa função é muito menor do que o seu domínio, ou seja, x (o tipo de entrada) pode assumir uma gama muito maior de valores do que (o resultado da função de hash).
</p>
<p>A API ICPBravo também implementa classes que permitem o uso das capacidades destes algoritmos, como pode ser verificado no trecho de código abaixo.</p>
<pre class="brush: java;">
// Instancia o algoritmo de digest
DigestAlgorithm alg = new SHA1();

// Gera o hash para os bytes de entrada
byte[] bts = "teste".getBytes();
byte hash [] = algs.digest(bts);
</pre>
<p>Veja mais exemplos do uso de algoritmos de digest em <a href='javadoc/br/com/oaks/ICPBravo/Exemplos.html#testaDigest()'>Exemplos</a></p>
<A NAME="numerosAleatorios()"><!-- - -></A>
<h2>Números Aleatórios</h2>
<p>Na ICPBravo são implemetados três algoritmos para geração de números pseudo aleatórios.</p>
<ul>
<li>LFSRs (linear feedback shift registers)</li>
<li>SHA1-PRNG</li>
<li>WindowsPRNG</li>
</ul>
<p><b>LFSR</b></p>
<p>O algoritmo utilizado é baseado no Non-binary Galois LFSR utilizando a combinação da saída de três LFSRs. Para a combinação é  utilizado o algortimo Alternating Stop-and-go. Nessa implementação, são utilizados registradores de 256 bits,  permitindo assim gerar chaves de até 256 bits sem com isso facilitar a criptoanálise das chaves geradas.</p>
<p><b>SHA1-PRNG</b></p>
<p>Utiliza o algoritmo descrito em FIPS Pub 186-2 apendice 3.1</p>
<p><b>WindowsPRNG</b></p>
<p>Utiliza a implemetação da Microsoft . Para o Windows XP é utilizado o FIPS Pub 186-2. Para o Windows Vista com SP1 é utilizado o NIST Special Publication 800-90. http://csrc.nist.gov/publications/nistpubs/800-90/SP800-90revised_March2007.pdf</p>
<p>A API ICPBravo possibilita o uso destes algoritmos por meio de suas classe, conforme pode ser observado no trecho de código a seguir:</p>
<pre class="brush: java;">
PRNGAlgorithm alg = new LFSR(new ICPBravoProvider());
SecureRandom sr = algs.getRandom();
// Gera um número aleatório entre 0 e 511
int random = sr.nextInt(512);
</pre>
<p>Veja mais exemplos do uso de geração de números aleatórios em <a href='javadoc/br/com/oaks/ICPBravo/Exemplos.html#testaNumerosAleatorios()'>Exemplos</a></p>
<A NAME="pkcs()"><!-- - -></A>
<h2>PKCS - Public Key Criptography Standards</h2>
<p>A empresa RSA, nome este em função de seus fundadores, Ron Rivest, Adi Shamir e Len Adleman, tem um papel fundamental no mercado de normalizações e uma divisão no laboratório RSA mantém uma série de padrões denominados PKCS.</p>
<p>Os PKCS indicam um padrão de fato relativos aos formatos de transferência de dados de forma a garantir a interoperabilidade e compatibilidade entre aplicações, onde existia um vazio nas normas internacionais.</p>
<p>São doze os padrões utilizados:</p>
<ul>
<li>PKCS#1  <i>(RSA Encryption Standard)</i> - Normaliza o uso do algoritmo RSA para assinaturas e envelopes digitais. O formato de uma mensagem contendo uma assinatura digital está definido em PKCS#7.</li>
<li>PKCS#3  <i>(Diffie-Hellman Key Agreement Standard)</i> - Normaliza o uso do protocolo de acordo com as chaves Diffie-Hellman no estabelecimento de chaves secretas ou de sessão (em camadas de rede ou de transporte).</li>
<li>PKCS#5  <i>(Password-Based Encryption Standard)</i> - Descreve um método para criptografar um array de bytes utilizando uma chave secreta calculada com base em uma senha (Password-Based Encryption - PBE)</li>
<li>PKCS#6  <i>(Extended-Certificate Syntax Standard)</i> - Extende a definição dos cerficados X.509, permitindo a associação de outros atributos à entidade titular do certificado.</li>
<li>PKCS#7  <i>(Cryptographic Message Syntax Standard)</i> - Define uma sintaxe para mensagens criptografadas, como assinaturas e envelopes digitais, bem como um repositório para CRLs e certificados.</li>
<li>PKCS#8  <i>(Private-Key Information Syntax Standard)</i> - Define uma sintaxe para informações de chaves privativas (valor, algoritmo e atributos).</li>
<li>PKCS#9  <i>(Selected Attribute Types)</i> - Atributos que podem estar associados a chaves, assinaturas, certificados, etc.</li>
<li>PKCS#10 <i>(Certification Request Syntax Standard)</i> - Define uma sintaxe para pedidos de certificados.</li>
<li>PKCS#11 <i>(Cryptographic Token Interface Standard)</i> - Define uma API, chamada de Cryptoki, para dispositivos criptográficos (que armazenam e executam algoritmos criptográficos).</li>
<li>PKCS#12 <i>(Personal Information Exchange Syntax)</i> - Descreve uma sintaxe para a transferência de informações de identificação pessoal, incluindo chaves privativas, certificados, chaves secretas e extensões.</li>
<li>PKCS#13 <i>(Elliptic Curve Cryptographic Standard)</i> - Ainda em desenvolvimento, e será dedicada às técnicas de criptografia baseada em curvas elípticas.</li>
<li>PKCS#15 <i>(Cryptographic Token Interface Format Standard)</i> - Descrevem uma forma de utilizar e identificar tokens criptográficos.</li>
</ul>
<p>O entendimento destes padrões será mais amplamente discutido no decorrer deste documento.</p>
<A NAME="asn1()"><!-- - -></A>
<h2>ASN.1 - Abstract Syntax Notation number one</h2>
<p>ASN.1 ou Abstract Syntax Notation One é uma notação que permite definir tipos de dados simples e complexos e especificar valores que estes tipos podem assumir.</p>
<p>É importante descrever esta notação pois a maioria dos padrões de PKCS são em definidos em notação ASN.1 e, será muito comum nos depararmos com objetos ASN1 nos objetos que implementam relações com certificação digital.</p>
<p>Os valores que são transmitidos podem ser de diversos tipos. Existem os tipos simples e outros, mais complexos, que são formados de vários tipos simples combinados. Cada tipo recebe uma denominação que o distingue, de forma inequívoca de todos os demais tipos. Algumas das maneiras de definir novos tipos são:</p>
<ul>
<li>uma sequência (ordenada) de tipos existentes</li> 
<li>uma sequência não ordenada de tipos existentes</li> 
<li>uma seleção de um dentre um conjunto de tipos</li>
</ul>
<p>Estes são denominados tipos estruturados. Cada tipo recebe um rótulo ("tag"). Um mesmo rótulo pode ser atribuído a mais de um tipo cuja particular identificação será decidida pelo contexto em que o rótulo for usado.</p>
<p>Existem quatro classes de rótulos:</p>
<ul>
<li><b>UNIVERSAL</b>: pode ser atribuído a um tipo simples ou a um mecanismo de construção, conforme especificado na tabela A.1.</li>
<li><b>APLICAÇÃO</b>: rótulos atribuídos a tipos por padrões específicos. Num particular padrão os rótulos da classe de APLICAÇ[[Atilde]]O somente podem ser atribuídos a um único valor.</li>
<li><b>PRIVADA</b>: rótulos usados numa empresa especifica.</li>
<li><b>ESPECIFICADO-POR-CONTEXTO</b>: interpretado de acordo com o contexto em que é usado.</li>
</ul>
<br>
<table>
<tr><th colspan='2'>TABELA A.1 Rotulo atribuídos na classe universal</th></tr>
<tr><td>UNIVERSAL 1</td><td>boleano</td></tr>
<tr><td>UNIVERSAL 2</td><td>inteiro</td></tr>
<tr><td>UNIVERSAL 3</td><td>string de bits</td></tr>
<tr><td>UNIVERSAL 4</td><td>string de octetos</td></tr>
<tr><td>UNIVERSAL 5</td><td>nulo</td></tr>
<tr><td>UNIVERSAL 6</td><td>id de objetos</td></tr>
<tr><td>UNIVERSAL 7</td><td>descritor de objetos</td></tr>
<tr><td>UNIVERSAL 8</td><td>externo</td></tr>
<tr><td>UNIVERSAL 9-15</td><td>reservados para adendos ao padrão</td></tr>
<tr><td>UNIVERSAL 16</td><td>SEQUENCE e SEQUENCE-OF</td></tr>
<tr><td>UNIVERSAL 17</td><td>SET e SET-OF</td></tr>
<tr><td>UNIVERSAL 18-22, 25-27</td><td>string de conjuntos de caracteres</td></tr>
<tr><td>UNIVERSAL 23-24</td><td>hora</td></tr>
<tr><td>UNIVERSAL 28,...</td><td>reservados para adendos ao padrão</td></tr>
</table>
<p>O valor do rótulo é especificado indicando-se sua classe e o número dentro da classe (que deve ser inteiro não negativo), em notação decimal.</p>
<p>As regras de codificação sempre conduzem o rótulo do tipo, explícita ou implicitamente, bem como alguma representação do valor do tipo.</p>
<p>ASN.1 ou Abstract Syntax Notation One e uma notação que permite definir tipos complexos e especificar valores destes tipos. As regras de codificação constituem outro padrão que aplicadas ao valor de um certo tipo definido pela ASN.1 resultam na especificação completa dos valores daquele tipo durante a transferência. As regras de codificação sempre forçam a transmissão do rótulo de um tipo, implícita ou explicitamente, juntamente com a representação do seu valor.</p>
<p>A API ICPBravo implementa classes para utilização dos pacotes ASN.1 dentro do package <i>br.com.oaks.ICPBravo.asn1</i> e seus subpacotes.</p>
<p>A API ICPBravo contempla o reconhecimento dos OID's (Identificadores de objetos ASN.1) mais utilizados, reconhecidos pela ICP-Brasil, que poderá ser encontrado na classe br.com.oaks.ICPBravo.asn1.oiw.OIWObjectIdentifiers.</p>
<p>Por meio desta classe é possível acessar uma lista de OID's previamente cadastrada, e também é possível a inclusão de OID's específicos.</p>
-->

<A NAME="certificadosDigitais()"><!-- --></A>
<h2>Certificados Digitais</h2>
<p>Muito se fala em certificados digitais, mas o que é um certificado digital na realidade?</p>
<p>Trata-se de um conjunto de informações que são armazenadas em um repositório, que permitem identificar o seu proprietário (subject), o seu emissor (issuer) e sua chave pública, bem como algumas informações adicionais que serão descritas em outros capítulos desta documentação.</p>
<p>Este conjunto de informações pode ser armazenado em um arquivo do sistema operacional (PKCS#12 ou JKS), porém isto ocasiona que, no caso da perda da máquina ou mesmo da invasão desta, este certificado fique vulnerável. Possibilitando que pessoas não autorizadas possam realizar operações com o certificado de forma não autorizada.</p>
<p>Outra opção é armazenar este certificado em um dispositivo criptográfico, que pode ser: Um cartão smartcard, que pode ser lido através de uma interface leitora de cartão, um token criptográfico, ou em alguns casos, um hardware específico, chamado de HSM.</p>
<p>Estas opções garantem uma maior segurança do certificado, uma vez que nunca permitem a exportação da chave privativa de dentro de seu hardware.</p>
<p>Outras características importantes dos certificados residem no fato de que são emitidos por instituições confiáveis, chamadas de AC (Autoridades Certificadoras).</p>
<p>A estas ACs cabem as tarefas de:</p>
<ul>
<li>Manter a mais rígida segurança possível para a chave privativa da AC;</li>
<li>Assegurar que seu próprio certificado seja amplamente distribuído;</li>
<li>Emissão de certificados;</li>
<li>Revogação de certificados;</li>
<li>Renovação de certificados;</li>
<li>Emissão da lista de certificados revogados;</li>
<li>Publicação da lista de certificados revogados;</li>
<li>Disponibilizar a situação do certificado, quando requerida;</li>
<li>Gerência de chaves criptográficas;</li>
<li>Publicação de suas regras operacionais;</li>
<li>Fiscalização do cumprimento das políticas pelos usuários.</li>
</ul>
<p>A API ICPBravo implementa algumas funcionalidades para utilizar certificados digitais.</p>
<p>São implementados na API por meio das classes no pacote <i>br.com.oaks.ICPBravo.certs</i>, sendo que a principal classe é a <i>ICPBravoCertificate</i>, responsável por recuperar e validar as informações do certificado.</p>
<p>Para certificados de usuário ou de ACs, modelos X.509 v3, existem classes que permitem codificar e decodificar estes e testar as extensões definidas pela ICP-Brasil.</p>

<h3>Ler informações dos certificados digitais</h3>
<p>A API ICP-Bravo implementa um conjunto de classes que permite gerenciar repositórios de certificados digitais.</p>
<p>Por meio destes gerenciadores, é possível listar os certificados e interagir-se com os dispositivos.</p>
<p>O próximo exemplo busca apresentar um método para recuperar certificados disponíveis no Windows.</p>
<pre class="brush: java;">
ICPBravoManager manager = new WindowsMyManager();
ICPBravoCertificate cert = manager.GetCertificateByAlias("Pessoa 1"); // Recuperamos o certificado pelo seu alias
</pre>
ou poderíamos ler todos os certificados instalados no dispositivo
<pre class="brush: java;">
List&lt;ICPBravoCertificate&gt; certs = manager.Certificates; // recuperamos a lista com todos os certificados presente no gerenciador
</pre>

<p>
De posse do certificado, vamos analizá-lo de forma a garantir a sua capacidade. A nossa análise consistirá basicamente de ler as informações relevantes do certificado e apresentá-las no System.out.</p>
<pre class="brush: java;">
Console.WriteLine("é autoassinado: "+cert.IsAutoSign);
Console.WriteLine("é certificador de sigilo: "+cert.IsSecrecy);
Console.WriteLine("é ICPBrasil: "+cert.IsICPBrasil);
Console.WriteLine("é raiz ICPBrasil: "+cert.IsICPBrasilRoot);
Console.WriteLine("pode assinar: "+cert.IsToSign);
Console.WriteLine("crlSign: "+cert.IsKeyUsageExtensionCrlSign);
Console.WriteLine("dataEncipherment: "+cert.IsKeyUsageExtensionDataEncipherment);
Console.WriteLine("decipherOnly: "+cert.IsKeyUsageExtensionDecipherOnly);
Console.WriteLine("encipherOnly: "+cert.IsKeyUsageExtensionEncipherOnly);
Console.WriteLine("digitalSignature: "+cert.IsKeyUsageExtensionDigitalSignature);
Console.WriteLine("keyAgreement: "+cert.IsKeyUsageExtensionKeyAgreement);
Console.WriteLine("KeyCertisign: "+cert.IsKeyUsageExtensionKeyCertisign);
Console.WriteLine("KeyEncipherment: "+cert.IsKeyUsageExtensionKeyEncipherment);
Console.WriteLine("NonRepudiation: "+cert.IsKeyUsageExtensionNonRepudiation);
try {
	cert.VerifyAllSignatures();
	Console.WriteLine("certificado válido: OK");
} catch (Exception e1) {
	Console.WriteLine("certificado válido: Falha "+e1.Message);
}
try {
    ICPBravoManager myTrustedCerts = new ICPBrasilManager();
	cert.TryTrustedValidate(myTrustedCerts);
	Console.WriteLine("certificado confiável: OK");
} catch (Exception e1) {
	Console.WriteLine("certificado confiável: Falha "+e1.Message);
}
try {
	ICPBravoCA ac = cert.IssuerObject;
	if (ac != null) {
		Console.WriteLine("AC: "+ac.ToString());
		Console.WriteLine("AC URL: "+ac.URLCrl[0]);
		ICPBravoCRL crl = ac.GetValidCRL(null, null);
		Console.WriteLine("CRL OK: "+crl.ThisUpdate+" até "+crl.NextUpdate);
	} else
		Console.WriteLine("Não tem AC");
} catch (Exception e) {
	Console.WriteLine("Falha na verificação de CRL "+e.ToString());
}
// Informações gerais
foreach (var informacaoCertificado in cert.GeneralInformation)
	Console.WriteLine(informacaoCertificado.Description+": "+informacaoCertificado.Value);
	
foreach (var informacaoCertificado in cert.IssuerDN.GetValues())
    Console.WriteLine(informacaoCertificado.ToString());

foreach (var informacaoCertificado in cert.SubjectDN.GetValues())
    Console.WriteLine(informacaoCertificado.ToString());

foreach (var informacaoCertificado in cert.SubjectAlternativeNamesExtensions)
    Console.WriteLine(informacaoCertificado.Description + ": " + informacaoCertificado.Value);

foreach (var informacaoCertificado in cert.KeyUsageExtension)
    Console.WriteLine(informacaoCertificado.Description + ": " + informacaoCertificado.Value);

foreach (var informacaoCertificado in cert.ExtendedKeyUsageExtension)
    Console.WriteLine(informacaoCertificado.Description + ": " + informacaoCertificado.Value);

foreach (var informacaoCertificado in cert.CertificatePoliciesExtensions)
    Console.WriteLine(informacaoCertificado.Description + ": " + informacaoCertificado.Value);
	
foreach (var informacaoCertificado in cert.CRLDistributionPointsExtensions)
    Console.WriteLine(informacaoCertificado.Description + ": " + informacaoCertificado.Value);

foreach (var informacaoCertificado in cert.ConstroiSubjectAlternativeNamesExtensions())
    Console.WriteLine(informacaoCertificado.Description + ": " + informacaoCertificado.Value);
</pre>
<!-- <p>Veja mais exemplos do uso de certificados digitais em <a href='javadoc/br/com/oaks/ICPBravo/Exemplos.html#testaCertificadoX509v3()'>Exemplos</a></p>  -->
<A NAME="signedData()"><!-- --></A>
<h2>Assinaturas Digitais</h2>
<p>Uma assinatura digital deve ser interpretado como um procedimento análogo ao da assinatura manuscrita, onde deve ser possível:</p>
<ul>
<li>Autenticação - Identificação inequívoca das partes envolvidas no processo, assim como ocorre em cartórios;</li>
<li>Integridade - As informações não podem ser modificadas, o que invalidaria a assinatura e garante ao signatário e aos seus destinatários que o conteúdo assinado não foi modificado;</li>
<li>Não Reutilização - Não é possível utilizar uma mesma assinatura para mais de um documento(*1), o que também garante ao signatário que sua assinatura não possa ser copiada para outros documentos;</li>
<li>Não Repúdio - O autor da assinatura não tem como negar sua autoria, o que garante aos receptores da assinatura que o signatário não poderá contestar sua assinatura.</li>
</ul>
<p>Sendo assim, para produzir uma assinatura digital, o procedimento pode ser descrito em:</p>
<ul>
<li>Criar um resumo de um documento (conhecido como hash do documento), que é feito por algoritmos que garantem que um mesmo conteúdo sempre gere o mesmo hash e, pequenas alterações no conteúdo produzam hashs completamente diferentes;</li>
<li>Criptografar este resumo junto com outras informações relevante da assinatura (data/hora, tipo do documento, etc.) com o uso da chave privativa, o que garante que apenas o proprietário do certificado possa realizar tal operação;</li>
<li>Unir estas informações em um pacote de forma que seja possível enviá-las, junto com as informações de autoria e chave pública do signatário para os destinatários, chamado de pacote PKCS#7(*2).</li>
</ul>
<p>Desta forma é possível realizar a operação inversa, ou seja descriptografar esta assinatura com a chave pública do signatário (que pode ser recuperada do certificado público do signatário) e verificar sua autoria.</p>
<p>A API ICPBravo implementa algumas classe para o uso de assinatura digital, em conformidade com a RFC3852, que descreve as especificações de CMS, que estão dentro do pacote <i>br.com.oaks.ICPBravo.cms</i> e são basicamente as classes <i>CMSSignedData</i> contendo informações do pacote e <i>CMSSignerInformation</i> que contém as informações do signatário.
<br>No exemplo a seguir criaremos uma nova assinatura, armazenando-a em um array de bytes:</p>
<pre class="brush: java;">
byte[] bts = ICPBravoUtil.ToByteArray("conteudo");

CMSSignedData sd = new CMSSignedData();

// O conteúdo a ser assinado
sd.DataBytes = bts;

// A linha abaixo indica que queremos que o conteúdo assinado esteja encapsulado dentro da assinatura
sd.SetEncapsulate(true);

// Adicionar o signatário
sd.AddSigner(cert);

// Criar o pacote
byte[] sdPkcs7CMS = sd.ASN1Encoded;
</pre> 
<p>Agora faremos a operação inversa, ou seja, abrir o pacote de assinatura e verificar seus signatários.</p>
<pre class="brush: java;">
CMSSignedData sd = new CMSSignedData(sdPkcs7CMS);
sd.Verify(); // verifica a assinatura
byte [] bts = sd.DataBytes; // Recebe o conteúdo assinado de volta, 
				// uma vez que o conteúdo foi adicionado a assinatura

var signers = sd.Signers; // Lista todos os signatários da assinatura
foreach (CMSSignerInformation signerInformation in signers) {
    Console.WriteLine("Signer: "+signerInformation.Certificate.Name);
	
	// Lista todos os atributos assinados
	var pkcs9SignedAttributes = signerInformation.SignedAttributes;
	var signedAttributes = pkcs9SignedAttributes.Attributes;
    foreach (var attribute in signedAttributes) {
		Console.WriteLine(attribute.Description+": "+attribute.ToString());
	}
	
	// Lista todos os atributos não assinados (como por exemplo o TimeStampToken)
	var pkcs9UnsignedAttributes = signerInformation.UnsignedAttributes;
	var unsignedAttributes = pkcs9UnsignedAttributes.Attributes;
	foreach (var attribute in unsignedAttributes) {
        Console.WriteLine(attribute.Description + ": " + attribute.ToString());
    }
}
</pre>
<!-- <p>Veja mais exemplos do uso de assinaturas digitais em <a href='javadoc/br/com/oaks/ICPBravo/Exemplos.html#testaSignedData()'>Exemplos</a></p> -->
<br>
<i>(*1) Devido a operação de hash poder, pelo menos matematicamente, produzir o mesmo hash para mais de modelo de documento diferente, entende-se que não é possível produzir o mesmo hash pelo menos para documentos que tenham conteúdos coerentes, ou seja, alterar o conteúdo de um documento de forma a obter uma alteração desejável não deve produzir um mesmo hash do documento original.</i>
<br><i>(*2) Devido a exigências da ICP-Brasil, este pacote deve ser um CADES, que é de certa forma uma extensão do PKCS#7/CMS ou um XADES, que é uma assinatura em arquivos XML.</i>

<!-- 
<A NAME="envelopedData()"><!-- - -></A>
<h2>Pacotes de Criptografia</h2>
<p>São chamados de pacotes de criptografia, pacotes onde é possível enviar e receber informações criptografadas, permitindo a sua abertura sem a divulgação de nenhum segredo nestes, caso sejam interceptados.</p>
<p>Na definição dos pacotes PKCS#7/CMS, são conhecidos como EnvelopedData.</p>
<p>Como o uso de algoritmos assimétricos em criptografia de grandes documentos é inviável devido ao tempo necessário para o processo, 
e o uso de apenas algoritmos simétricos implicaria no problema de divulgar o segredo entre as partes, 
o que enfraqueceria a segurança do processo, uma técnica bastante eficaz para esta criptografia é:</p>
<ul>
<li>Gerar uma chave secreta (segredo) aleatoriamente por meio de um algoritmo simétrico;</li>
<li>Criptografar o documento com esta chave secreta;</li>
<li>Criptografar esta chave secreta com a chave pública do destinatário (de forma que apenas o destinatário possa descriptografar esta chave).</li>
<li>Empacotar o conteúdo e a chave, ambos criptografados, bem como as informações sobre o procedimento adotado, de forma a poder enviar estas informações para o(s) destinatário(s).</li>
</ul>
Ao receber estas informações, o destinatário executa os seguintes passos:
<ul>
<li>Descriptografa esta senha secreta com sua chave privativa;</li>
<li>Descriptografa o documento com a senha secreta encontrada;</li>
</ul>
<p>Este modelo produz uma forma segura de se enviar informações criptografadas entre pessoas/instituições.</p>
<p>A API ICPBravo implementa algumas classe para o uso de envelopes digitais, em conformidade com a RFC3852, que descreve as especificações de CMS, que estão dentro do pacote <i>br.com.oaks.ICPBravo.cms</i> e são basicamente as classes <i>CMSEnvelopedData</i> contendo informações do pacote e <i>CMSRecipientInformation</i> que contém as informações dos recipientes.
<br>No exemplo a seguir criaremos um novo pacote de criptografia, armazenando-a em um array de bytes:</p>
<pre class="brush: java;">
byte [] bts = "conteúdo".getBytes();
CMSEnvelopedData ed = new CMSEnvelopedData(provider, new AES128CBC(provider));
ed.setData(bts);
ed.addKeyTransRecipient(cert1);
byte [] edPkcs7CMS = ed.getASN1Encoded();
</pre> 
<p>Agora faremos a operação inversa, ou seja, abrir o pacote de criptografia e recuperar seu conteúdo.</p>
<pre class="brush: java;">
CMSEnvelopedData ed = new CMSEnvelopedData(provider, edPkcs7CMS);
byte [] bts = ed.getRecipient(cert, cert.getPrivateKey());
</pre>
<p>Veja mais exemplos do uso de envelopes digitais em <a href='javadoc/br/com/oaks/ICPBravo/Exemplos.html#testaEnvelopedData()'>Exemplos</a></p>
<i>ps.: Algumas alternativas deste algoritmo também são aceitas, como incluir informações do remetente, ou mesmo criptografar com uma chave pré-concebida, porém este é o método mais utilizado.</i>
<A NAME="csr()"><!-- - -></A>
<h2>CSR - Certificate Signing Request</h2>
<p>Trata-se de uma forma eficiente e segura de pacote de solicitação de certificado digital.</p>
<p>Com esta técnica será possível gerar um par de chaves em um dispositivo criptográfico, mantendo a chave privativa em um local inviolável, e gerar um pacote de solicitação de certificado digital contendo a chave pública, e assinado pela chave privativa.</p>
<p>Este pacote é submetido à autoridade ceritificadora (AC), onde o certificado poderá ser gerado e devolvido ao usuário para que possa ser instalado no dispositivo criptográfico.</p>
<p>A API ICPBravo implementa algumas classe para o uso de CSR, em conformidade com PKCS#10.</p>
-->
</body>
</html>
